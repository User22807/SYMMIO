<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>SYMMIO</title>
    <link rel="icon" type="image/x-icon" href="./assets/Favicon.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.159.0/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.5.1/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.5.1/ScrollTrigger.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.4.0/TextPlugin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/scrollify/1.0.21/jquery.scrollify.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.4.1/jquery.easing.min.js"></script>

    <link rel="stylesheet" href="./styles/style.css">
</head>


<body>

    <nav>
        <ul class="menu__list">
            <div class="navbar_wrapper">
                <div class="navbar_col" id="mainMenuWrap">
                    <li class="menu__item">
                        <a class="" href="./index.html"> <img href="./index.html" src="./assets/SYMMIO-Logo.png"
                                class="menu__link logo" />
                        </a>
                    </li>

                </div>
                <div class="navbar_col">
                    <li class="menu__item">
                        <a class="menu__link" href="./index.html">Home</a>
                    </li>
                    <li class="menu__item" href="./fronts.html">
                        <a href="./fronts.html" class="tradeBtn">Trade</a>
                    </li>
                </div>
            </div>
        </ul>

        <input type="checkbox" id="menu_trigger" class="menu-trigger" />
        <div class="overlay" id="overlayID">
            <ul class="menu-links">
                <div class="navbar_col">
                    <a href="#Home">
                        <img src="./assets/SYMMIO-Logo.png" class="logo-smallscreen" />
                    </a>
                    <div class="tradeSection">
                        <li class="menu__item">
                            <a class="menu__link" href="#Home">Home</a>
                        </li>
                        <li class="menu__item">
                            <a class="menu__link" href="#HowItWorks">How it works</a>
                        </li>
                        <li class="menu__item">
                            <a class="menu__link" href="#reachus">Learn more</a>
                        </li>
                    </div>
                    <div class="navbar_col">
                        <li class="menu__item">
                            <label class="trade-switch">
                                <input id="trade-switch2-id" type="checkbox" checked>
                                <a class="tradeBtn2">Trade</a>
                            </label>
                        </li>
                    </div>
                </div>
            </ul>
        </div>
        <label for="menu_trigger" class="hamburger-menu">
            <span></span>
            <span></span>
            <span></span>
        </label>
    </nav>

    <div class="webGL" id="webGLID"></div>

  


    <main id="main">
        <div id="progressbar"></div>
        <div class="scrollDown-wrapper" id="scrollDownID">
            <div class="scroll-down"></div>
        </div>

        <div class="switchWrap">
            <label class="minimal-switch">
                <input id="toggleSwitch" type="checkbox" checked>
                <span class="minimal-slider round"></span>
            </label>
        </div>


        <section class="sectionWrap one" id="HowItWorks">
            <div class="box__text">
                <div class="list_top"></div>
                <div class="subtitle"></div>
                <div class="title"></div>
                <div class="titleSYMM "></div>
            </div>
        </section>

        <section class="sectionWrap two" id="HowItWorks">
            <div class="box__text">
                <div class="list_top"></div>
                <div class="title"></div>
                <div class="subtitle"></div>
                <div class="titleSYMM "></div>
            </div>
        </section>

        <section class="sectionWrap three" id="HowItWorks">
            <div class="box__text">
                <div class="list_top"></div>
                <div class="titleSYMM "></div>
                <div class="subtitle"></div>
                <div class="title"></div>
            </div>
        </section>

        <section class="sectionWrap four" id="HowItWorks">
            <div class="box__text">
                <div class="list_top"></div>
                <div class="subtitle"></div>
                <div class="title"></div>
                <div class="titleSYMM "></div>
            </div>
        </section>

        <section class="sectionWrap five" id="HowItWorks">
            <div class="box__text">
                <div class="list_top"></div>
                <div class="title"></div>
                <div class="subtitle"></div>
                <div class="titleSYMM "></div>
            </div>
        </section>

        <section class="sectionWrap six" id="HowItWorks">
            <div class="box__text">
                <div class="list_top"></div>
                <div class="title"></div>
                <div class="subtitle"></div>
                <div class="titleSYMM "></div>

            </div>
        </section>

        <section class="sectionWrap seven" id="HowItWorks">
            <div class="box__text">
                <div class="list_top"></div>
                <div class="titleSYMM "></div>
                <div class="title"></div>
                <div class="subtitle"></div>
            </div>
        </section>

    </main>

</body>

<script id="vertexShader" type="x-shader/x-vertex">
			void main()	{
				gl_Position = vec4( position, 1.0 );
			}
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
    uniform float iClick;
    uniform vec2 iResolution;
    uniform float iTime;
    uniform vec2 iMousePos;
    uniform vec3 iAnimProgress_1;
    uniform vec3 iAnimProgress_2;
    uniform vec3 iAnimProgress_3;
    uniform vec3 iAnimProgress_4;
    const ivec2 char_space = ivec2(0, 0);
    const ivec2 char_exclam = ivec2(-2147352576, 135274560);
    const ivec2 char_quotedbl = ivec2(0, 338186240);
    const ivec2 char_numbersign = ivec2(-494600192, 338229411);
    const ivec2 char_dollar = ivec2(-2058944512, 475277538);
    const ivec2 char_percent = ivec2(1179385856, 105660480);
    const ivec2 char_ampersand = ivec2(-1572143104, 68429858);
    const ivec2 char_quoteright = ivec2(0, 135270400);
    const ivec2 char_parenleft = ivec2(1090781184, 269488160);
    const ivec2 char_parenright = ivec2(16842752, 68173953);
    const ivec2 char_asterisk = ivec2(-985530368, 139751489);
    const ivec2 char_plus = ivec2(-2130706432, 1057264);
    const ivec2 char_comma = ivec2(16908800, 0);
    const ivec2 char_hyphen = ivec2(0, 224);
    const ivec2 char_period = ivec2(131072, 0);
    const ivec2 char_slash = ivec2(1077936128, 4210752);
    const ivec2 char_zero = ivec2(578945024, 136874258);
    const ivec2 char_one = ivec2(-2130247680, 135798848);
    const ivec2 char_two = ivec2(1078951936, 474251456);
    const ivec2 char_three = ivec2(71761920, 1044398274);
    const ivec2 char_four = ivec2(-503054336, 271601811);
    const ivec2 char_five = ivec2(71761920, 1040480514);
    const ivec2 char_six = ivec2(608632832, 403179762);
    const ivec2 char_seven = ivec2(1082195968, 1044398144);
    const ivec2 char_eight = ivec2(608632832, 474253538);
    const ivec2 char_nine = ivec2(33751040, 474253794);
    const ivec2 char_colon = ivec2(131072, 8192);
    const ivec2 char_semicolon = ivec2(16908800, 8192);
    const ivec2 char_less = ivec2(1090781184, 269488144);
    const ivec2 char_equal = ivec2(-536870912, 63491);
    const ivec2 char_greater = ivec2(16842752, 68174081);
    const ivec2 char_question = ivec2(-2147352576, 474234944);
    const ivec2 char_at = ivec2(-1605959680, 474278227);
    const ivec2 char_A = ivec2(-465010688, 136874259);
    const ivec2 char_B = ivec2(608665600, 507807986);
    const ivec2 char_C = ivec2(608632832, 474220560);
    const ivec2 char_D = ivec2(608665600, 507808018);
    const ivec2 char_E = ivec2(542081024, 1040451824);
    const ivec2 char_F = ivec2(541097984, 1040451824);
    const ivec2 char_G = ivec2(609157120, 474220563);
    const ivec2 char_H = ivec2(608731136, 574917106);
    const ivec2 char_I = ivec2(-2130247680, 470818880);
    const ivec2 char_J = ivec2(71761920, 541098242);
    const ivec2 char_K = ivec2(-1572306944, 572794928);
    const ivec2 char_L = ivec2(542081024, 33818640);
    const ivec2 char_M = ivec2(608731136, 577546578);
    const ivec2 char_N = ivec2(608731136, 574921043);
    const ivec2 char_O = ivec2(608632832, 474253586);
    const ivec2 char_P = ivec2(541097984, 507807984);
    const ivec2 char_Q = ivec2(-1572143104, 474253586);
    const ivec2 char_R = ivec2(-1572306944, 507807984);
    const ivec2 char_S = ivec2(71761920, 474220770);
    const ivec2 char_T = ivec2(-2130575360, 1041244224);
    const ivec2 char_U = ivec2(608632832, 574916882);
    const ivec2 char_V = ivec2(1090650112, 574916769);
    const ivec2 char_W = ivec2(-1522204672, 574916946);
    const ivec2 char_X = ivec2(1145602048, 574902337);
    const ivec2 char_Y = ivec2(-2130575360, 574902336);
    const ivec2 char_Z = ivec2(1078951936, 1044398144);
    const ivec2 char_bracketleft = ivec2(1083113472, 1007161376);
    const ivec2 char_backslash = ivec2(67108864, 266305);
    const ivec2 char_bracketright = ivec2(34045952, 505430145);
    const ivec2 char_asciicircum = ivec2(0, 136873984);
    const ivec2 char_underscore = ivec2(1015808, 0);
    const ivec2 char_quotereversed = ivec2(0, 135282688);
    const ivec2 char_a = ivec2(-1001455616, 28931);
    const ivec2 char_b = ivec2(608665600, 33847570);
    const ivec2 char_c = ivec2(542048256, 61456);
    const ivec2 char_d = ivec2(609157120, 541126930);
    const ivec2 char_e = ivec2(-532217856, 28947);
    const ivec2 char_f = ivec2(-2130575360, 269492448);
    const ivec2 char_g = ivec2(609161244, 61714);
    const ivec2 char_h = ivec2(608731136, 33847570);
    const ivec2 char_i = ivec2(-2130247680, 134230080);
    const ivec2 char_j = ivec2(-2130574332, 134225984);
    const ivec2 char_k = ivec2(-1031208960, 67670176);
    const ivec2 char_l = ivec2(-2130247680, 202383424);
    const ivec2 char_m = ivec2(-1521844224, 22866);
    const ivec2 char_n = ivec2(608731136, 30994);
    const ivec2 char_o = ivec2(608632832, 28946);
    const ivec2 char_p = ivec2(608665858, 30994);
    const ivec2 char_q = ivec2(609161248, 61714);
    const ivec2 char_r = ivec2(1082195968, 53344);
    const ivec2 char_s = ivec2(-1006141440, 61457);
    const ivec2 char_t = ivec2(-2130444288, 135295040);
    const ivec2 char_u = ivec2(609157120, 35090);
    const ivec2 char_v = ivec2(1115815936, 35089);
    const ivec2 char_w = ivec2(-1522204672, 35090);
    const ivec2 char_x = ivec2(-2104983552, 34976);
    const ivec2 char_y = ivec2(609161244, 35090);
    const ivec2 char_z = ivec2(-2138079232, 63616);
    const ivec2 char_braceleft = ivec2(-2129920000, 806363168);
    const ivec2 char_brokenbar = ivec2(-2130575360, 135274496);
    const ivec2 char_braceright = ivec2(-2130608128, 101720192);
    const ivec2 char_asciitilde = ivec2(0, 72630272);
    const ivec2 char_filledbox = ivec2(-405831680, 1048377843);
    const ivec2 char_sterling = ivec2(1083146240, 407375984);
    const ivec2 char_quotesingle = ivec2(0, 135274496);
    const ivec2 char_arrowleft = ivec2(1090519040, 1053168);
    const ivec2 char_onehalf = ivec2(-1543240648, 33818641);
    const ivec2 char_arrowright = ivec2(16777216, 1065457);
    const ivec2 char_arrowup = ivec2(-2130706432, 1077584);
    const ivec2 char_emdash = ivec2(0, 496);
    const ivec2 char_onequarter = ivec2(1175067680, 67637282);
    const ivec2 char_dblverticalbar = ivec2(1116012544, 338186401);
    const ivec2 char_threequarters = ivec2(1711938592, 101718082);
    const ivec2 char_divide = ivec2(16777216, 1049072);
    const ivec2 char_comma_saa5051 = ivec2(8454400, 0);
    const ivec2 char_period_saa5051 = ivec2(25362432, 0);
    const ivec2 char_colon_saa5051 = ivec2(65536, 32);
    const ivec2 char_semicolon_saa5051 = ivec2(8454400, 4096);
    const ivec2 char_section = ivec2(596119836, 474220770);
    const ivec2 char_Adieresis = ivec2(-465010688, 335573267);
    const ivec2 char_Odieresis = ivec2(608632832, 335573266);
    const ivec2 char_Udieresis = ivec2(608632832, 335579410);
    const ivec2 char_degree = ivec2(0, 407396352);
    const ivec2 char_adieresis = ivec2(-1001455616, 335573251);
    const ivec2 char_odieresis = ivec2(608632832, 2621666);
    const ivec2 char_udieresis = ivec2(609157120, 2621714);
    const ivec2 char_germandbls = ivec2(608600322, 203704530);
    const ivec2 char_currency = ivec2(1133019136, 35041);
    const ivec2 char_Eacute = ivec2(-531660800, 269547537);
    const ivec2 char_D_saa5052 = ivec2(1149698048, 474517794);
    const ivec2 char_L_saa5052 = ivec2(1083113472, 67637280);
    const ivec2 char_Aring = ivec2(-465010688, 134246675);
    const ivec2 char_eacute = ivec2(-532217856, 269512979);
    const ivec2 char_aring = ivec2(-1001455616, 134246659);
    const ivec2 char_ccedilla = ivec2(542050312, 61456);
    const ivec2 char_ugrave = ivec2(609157120, 68192530);
    const ivec2 char_agrave = ivec2(-1001455616, 68186371);
    const ivec2 char_ograve = ivec2(608632832, 68157666);
    const ivec2 char_egrave = ivec2(-532217856, 68186387);
    const ivec2 char_igrave = ivec2(-2130247680, 68157536);
    const ivec2 char_idieresis = ivec2(-2130247680, 335556672);
    const ivec2 char_edieresis = ivec2(-532217856, 335573267);
    const ivec2 char_ecircumflex = ivec2(-532217856, 136868115);
    const ivec2 char_ugrave_saa5054 = ivec2(609157120, 136349970);
    const ivec2 char_icircumflex = ivec2(-2130247680, 136839264);
    const ivec2 char_acircumflex = ivec2(-1001455616, 136868099);
    const ivec2 char_ocircumflex_saa5054 = ivec2(608632832, 136868114);
    const ivec2 char_ucircumflex = ivec2(609157120, 136839442);
    const ivec2 char_ccedilla_saa5054 = ivec2(542050328, 61456);

    ivec2 text_box_chars = ivec2(62, 16);

    float draw_char(vec2 coord, ivec2 char) {
        int pos_id = int(coord.x * 7.0) + int(coord.y * 9.0) * 7;
        int num = pos_id < 32 ? char.x : char.y;
        int val;

        if(pos_id < 32) {
            val = int(mod(float(num) / pow(2.0, float(pos_id)), 2.0));
        } else {
                // Handle the case where pos_id is greater than or equal to 32
                // by using a different bit manipulation technique.
            int shifted_pos_id = pos_id - 32;
            int pow_val = int(pow(2.0, float(shifted_pos_id)));
            val = (num / pow_val);
            val = val - (val / 2) * 2; // Use arithmetic to ensure val is 0 or 1
        }

        float col = val == 0 ? 0.0 : 1.0;

        return col;
    }

    vec3 draw_text_EZTEXT(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 5.0;
        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
            // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }
        ivec2 text_string_2[11];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_dollar);
        else if(charIndex == 3)
            current_char = ivec2(char_E);
        else if(charIndex == 4)
            current_char = ivec2(char_Z);
        else if(charIndex == 5)
            current_char = ivec2(char_space);
        else if(charIndex == 6)
            current_char = ivec2(char_T);
        else if(charIndex == 7)
            current_char = ivec2(char_E);
        else if(charIndex == 8)
            current_char = ivec2(char_X);
        else if(charIndex == 9)
            current_char = ivec2(char_T);
        else if(charIndex == 10)
            current_char = ivec2(char_space);

            // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }

    vec3 draw_text_you(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 5.0;
        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
        // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }
        ivec2 text_string_2[6];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_Y);
        else if(charIndex == 3)
            current_char = ivec2(char_O);
        else if(charIndex == 4)
            current_char = ivec2(char_U);
        else if(charIndex == 5)
            current_char = ivec2(char_space);

        // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }

    vec3 draw_text_dash(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 2.0;
        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
        // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }
        ivec2 text_string_2[6];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_emdash);
        else if(charIndex == 3)
            current_char = ivec2(char_emdash);
        else if(charIndex == 4)
            current_char = ivec2(char_emdash);
        else if(charIndex == 5)
            current_char = ivec2(char_space);

        // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }

    vec3 draw_text_party_a(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 5.0;
        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
        // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }
        ivec2 text_string_2[10];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_P);
        else if(charIndex == 3)
            current_char = ivec2(char_A);
        else if(charIndex == 4)
            current_char = ivec2(char_R);
        else if(charIndex == 5)
            current_char = ivec2(char_T);
        else if(charIndex == 6)
            current_char = ivec2(char_Y);
        else if(charIndex == 7)
            current_char = ivec2(char_space);
        else if(charIndex == 8)
            current_char = ivec2(char_A);
        else if(charIndex == 9)
            current_char = ivec2(char_space);    
        // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }

    vec3 draw_text_party_b(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 5.0;
        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
        // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }
        ivec2 text_string_2[10];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_P);
        else if(charIndex == 3)
            current_char = ivec2(char_A);
        else if(charIndex == 4)
            current_char = ivec2(char_R);
        else if(charIndex == 5)
            current_char = ivec2(char_T);
        else if(charIndex == 6)
            current_char = ivec2(char_Y);
        else if(charIndex == 7)
            current_char = ivec2(char_space);
        else if(charIndex == 8)
            current_char = ivec2(char_B);
        else if(charIndex == 9)
            current_char = ivec2(char_space);    
        // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }

    vec3 draw_text_arbiter(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 5.0;
        coord.x *= 1.1;
        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
        // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }
        ivec2 text_string_2[10];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_A);
        else if(charIndex == 3)
            current_char = ivec2(char_R);
        else if(charIndex == 4)
            current_char = ivec2(char_B);
        else if(charIndex == 5)
            current_char = ivec2(char_I);
        else if(charIndex == 6)
            current_char = ivec2(char_T);
        else if(charIndex == 7)
            current_char = ivec2(char_E);
        else if(charIndex == 8)
            current_char = ivec2(char_R);
        else if(charIndex == 9)
            current_char = ivec2(char_space);      
        // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }

    vec3 draw_text_intent_a(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 4.5;
        coord.x *= 1.4;

        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
        // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }
        ivec2 text_string_2[11];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_I);
        else if(charIndex == 3)
            current_char = ivec2(char_N);
        else if(charIndex == 4)
            current_char = ivec2(char_T);
        else if(charIndex == 5)
            current_char = ivec2(char_E);
        else if(charIndex == 6)
            current_char = ivec2(char_N);
        else if(charIndex == 7)
            current_char = ivec2(char_T);
        else if(charIndex == 8)
            current_char = ivec2(char_space);
        else if(charIndex == 9)
            current_char = ivec2(char_A);
        else if(charIndex == 10)
            current_char = ivec2(char_space);

        // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }

    vec3 draw_text_intent_b(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 4.5;
        coord.x *= 1.4;

        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
        // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }
        ivec2 text_string_2[11];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_I);
        else if(charIndex == 3)
            current_char = ivec2(char_N);
        else if(charIndex == 4)
            current_char = ivec2(char_T);
        else if(charIndex == 5)
            current_char = ivec2(char_E);
        else if(charIndex == 6)
            current_char = ivec2(char_N);
        else if(charIndex == 7)
            current_char = ivec2(char_T);
        else if(charIndex == 8)
            current_char = ivec2(char_space);
        else if(charIndex == 9)
            current_char = ivec2(char_B);
        else if(charIndex == 10)
            current_char = ivec2(char_space);

        // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }
    
    vec3 draw_text_btc_long(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 5.0;
        coord.x *= 1.4;
        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
        // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }
        ivec2 text_string_2[12];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_one);
        else if(charIndex == 3)
            current_char = ivec2(char_B);
        else if(charIndex == 4)
            current_char = ivec2(char_T);
        else if(charIndex == 5)
            current_char = ivec2(char_C);
        else if(charIndex == 6)
            current_char = ivec2(char_space);
        else if(charIndex == 7)
            current_char = ivec2(char_L);
        else if(charIndex == 8)
            current_char = ivec2(char_O);
        else if(charIndex == 9)
            current_char = ivec2(char_N);
        else if(charIndex == 10)
            current_char = ivec2(char_G);
        else if(charIndex == 11)
            current_char = ivec2(char_space);

        // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }

    vec3 draw_text_btc_short(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 5.0;
        coord.x *= 1.4;

        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
        // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }
        ivec2 text_string_2[13];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_one);
        else if(charIndex == 3)
            current_char = ivec2(char_B);
        else if(charIndex == 4)
            current_char = ivec2(char_T);
        else if(charIndex == 5)
            current_char = ivec2(char_C);
        else if(charIndex == 6)
            current_char = ivec2(char_space);
        else if(charIndex == 7)
            current_char = ivec2(char_S);
        else if(charIndex == 8)
            current_char = ivec2(char_H);
        else if(charIndex == 9)
            current_char = ivec2(char_O);
        else if(charIndex == 10)
            current_char = ivec2(char_R);
        else if(charIndex == 11)
            current_char = ivec2(char_T);
        else if(charIndex == 12)
            current_char = ivec2(char_space); 
        // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }

    vec3 draw_text_lock(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 4.5;
        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
        // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }
        ivec2 text_string_2[11];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_L);
        else if(charIndex == 3)
            current_char = ivec2(char_O);
        else if(charIndex == 4)
            current_char = ivec2(char_C);
        else if(charIndex == 5)
            current_char = ivec2(char_K);
        else if(charIndex == 6)
            current_char = ivec2(char_space);

        // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }

    vec3 draw_btc_short(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 5.0;
        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
        // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }
        ivec2 text_string_2[11];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_B);
        else if(charIndex == 3)
            current_char = ivec2(char_T);
        else if(charIndex == 4)
            current_char = ivec2(char_C);
        else if(charIndex == 5)
            current_char = ivec2(char_space);
        else if(charIndex == 6)
            current_char = ivec2(char_S);
        else if(charIndex == 7)
            current_char = ivec2(char_H);
        else if(charIndex == 8)
            current_char = ivec2(char_O);
        else if(charIndex == 9)
            current_char = ivec2(char_R);
        else if(charIndex == 10)
            current_char = ivec2(char_T);
        else if(charIndex == 11)
            current_char = ivec2(char_space);

        // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }

    vec3 draw_text_pool(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 4.5;
        coord.x *= 1.4;

        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
        // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }
        ivec2 text_string_2[14];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_I);
        else if(charIndex == 3)
            current_char = ivec2(char_N);
        else if(charIndex == 4)
            current_char = ivec2(char_T);
        else if(charIndex == 5)
            current_char = ivec2(char_E);
        else if(charIndex == 6)
            current_char = ivec2(char_N);
        else if(charIndex == 7)
            current_char = ivec2(char_T);
        else if(charIndex == 8)
            current_char = ivec2(char_space);
        else if(charIndex == 9)
            current_char = ivec2(char_P);
        else if(charIndex == 10)
            current_char = ivec2(char_O);
        else if(charIndex == 11)
            current_char = ivec2(char_O);
        else if(charIndex == 12)
            current_char = ivec2(char_L);
        else if(charIndex == 13)
            current_char = ivec2(char_space);

        // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }

    vec3 draw_text_execute(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 4.5;
        coord.x *= 1.4;

        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
        // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }
        ivec2 text_string_2[10];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_E);
        else if(charIndex == 3)
            current_char = ivec2(char_X);
        else if(charIndex == 4)
            current_char = ivec2(char_E);
        else if(charIndex == 5)
            current_char = ivec2(char_C);
        else if(charIndex == 6)
            current_char = ivec2(char_U);
        else if(charIndex == 7)
            current_char = ivec2(char_T);
        else if(charIndex == 8)
            current_char = ivec2(char_E);
        else if(charIndex == 9)
            current_char = ivec2(char_space);

        // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }

    vec3 draw_text_liquidate(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 4.5;
        coord.x *= 1.4;

        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
        // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }
        ivec2 text_string_2[12];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_L);
        else if(charIndex == 3)
            current_char = ivec2(char_I);
        else if(charIndex == 4)
            current_char = ivec2(char_Q);
        else if(charIndex == 5)
            current_char = ivec2(char_U);
        else if(charIndex == 6)
            current_char = ivec2(char_I);
        else if(charIndex == 7)
            current_char = ivec2(char_D);
        else if(charIndex == 8)
            current_char = ivec2(char_A);
        else if(charIndex == 9)
            current_char = ivec2(char_T);
        else if(charIndex == 10)
            current_char = ivec2(char_E);
        else if(charIndex == 11)
            current_char = ivec2(char_space);

        // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }

    vec3 draw_text_solvent(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 4.5;
        coord.x *= 1.4;

        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
        // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }

        ivec2 text_string_2[10];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_S);
        else if(charIndex == 3)
            current_char = ivec2(char_O);
        else if(charIndex == 4)
            current_char = ivec2(char_L);
        else if(charIndex == 5)
            current_char = ivec2(char_V);
        else if(charIndex == 6)
            current_char = ivec2(char_E);
        else if(charIndex == 7)
            current_char = ivec2(char_N);
        else if(charIndex == 8)
            current_char = ivec2(char_T);
        else if(charIndex == 9)
            current_char = ivec2(char_space);

        // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }

    vec3 draw_text_plus_onethousand(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 5.0;
        coord.x *= 1.3;

        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
        // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }
        ivec2 text_string_2[9];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_plus);
        else if(charIndex == 3)
            current_char = ivec2(char_dollar);
        else if(charIndex == 4)
            current_char = ivec2(char_one);
        else if(charIndex == 5)
            current_char = ivec2(char_zero);
        else if(charIndex == 6)
            current_char = ivec2(char_zero);
        else if(charIndex == 7)
            current_char = ivec2(char_zero);
        else if(charIndex == 8)
            current_char = ivec2(char_space);

        // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }

    vec3 draw_text_minus_onethousand(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 5.0;
        coord.x *= 1.3;

        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
        // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }
        ivec2 text_string_2[9];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_emdash);
        else if(charIndex == 3)
            current_char = ivec2(char_dollar);
        else if(charIndex == 4)
            current_char = ivec2(char_one);
        else if(charIndex == 5)
            current_char = ivec2(char_zero);
        else if(charIndex == 6)
            current_char = ivec2(char_zero);
        else if(charIndex == 7)
            current_char = ivec2(char_zero);
        else if(charIndex == 8)
            current_char = ivec2(char_space);

        // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }

    vec3 draw_text_safu(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 5.0;
        coord.x *= 1.3;

        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
        // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }
        ivec2 text_string_2[7];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_S);
        else if(charIndex == 3)
            current_char = ivec2(char_A);
        else if(charIndex == 4)
            current_char = ivec2(char_F);
        else if(charIndex == 5)
            current_char = ivec2(char_U);
        else if(charIndex == 6)
            current_char = ivec2(char_space);

        // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }

    vec3 draw_text_hedger(vec2 coord, vec2 pos) {
        coord += pos;
        coord *= 5.0;
        int charIndex = int(coord.x);
        coord.x -= float(int(coord.x));
        // Check if the character is outside the visible area
        if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
            return vec3(0.0); // Return transparent color for characters outside the screen
        }
        ivec2 text_string_2[9];
        ivec2 current_char = text_string_2[0]; // Initialize with a default character

        if(charIndex == 1)
            current_char = ivec2(char_space);
        else if(charIndex == 2)
            current_char = ivec2(char_H);
        else if(charIndex == 3)
            current_char = ivec2(char_E);
        else if(charIndex == 4)
            current_char = ivec2(char_D);
        else if(charIndex == 5)
            current_char = ivec2(char_G);
        else if(charIndex == 6)
            current_char = ivec2(char_E);
        else if(charIndex == 7)
            current_char = ivec2(char_R);
        else if(charIndex == 8)
            current_char = ivec2(char_space);

        // Calculate the color for the character and return it as a vec3.
        return vec3(draw_char(coord, current_char));
    }
    
    // Includes and constants
    #define SCA(a)      vec2(sin(a), cos(a))
    #define HSV2RGB_K  vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0)
    #define HSV2RGB(c) (c.z * mix(HSV2RGB_K.xxx, clamp(abs(fract(c.xxx + HSV2RGB_K.xyz) * 6.0 - HSV2RGB_K.www) - HSV2RGB_K.xxx, 0.0, 1.0), c.y))

    // Sun direction and color
    vec3 sunDir = normalize(vec3(0.0, -2.0, 20.0));
    vec3 sunCol;

    // Function for rendering the outer sky
    vec3 outerSkyRender(vec3 ro, vec3 rd) {
        vec3 col = HSV2RGB(vec3(1.0, 0.00, 0.008));
        sunCol = HSV2RGB(vec3(0.01, 0.5, (iAnimProgress_1.x * 0.0002)));
    //(iAnimProgress_1.x*0.002)+(iAnimProgress_3.y*0.0006);
    // Sun settings
        col += sunCol / pow((1.002 - dot(sunDir, rd)), 1.9);

    // Horizon light modifier
        vec3 gcol = HSV2RGB(vec3(1.0, 0.4, 0.008 - (iAnimProgress_4.z * 0.004*(1.0-iAnimProgress_1.x)) - (iAnimProgress_1.x * 0.0075) + (iAnimProgress_3.y * 0.0006)));
        gcol = gcol * 0.3;

    // Atmosphere air color
        col += HSV2RGB(vec3(0.27, 0.0, 0.1));

        col += gcol / max(abs(rd.y), 0.0);
        return col;
    }

    // Function for finding the intersection of a ray with a plane
    float rayPlane(vec3 ro, vec3 rd, vec4 p) {
        return -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);
    }

    // Function to calculate the value of an equilateral triangle
    float equilateralTriangle(vec2 p) {
        const float k = sqrt(3.0);
        p.x = abs(p.x) - 1.0;
        p.y = p.y + 1.0 / k;
        if(p.x + k * p.y > 0.0)
            p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;
        p.x -= clamp(p.x, -2.0, 0.0);
        return -length(p) * sign(p.y);
    }
    vec3 anim_1(vec3 col, vec3 ro, vec3 rd) {
    // Triangle fill color
        vec3 fillColor = HSV2RGB(vec3(0.0, 0.3, 0.0));

    // Triangle calculations
        const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);
        float tpd = rayPlane(ro, rd, tpdim);
        vec3 pp = ro + rd * tpd;
        vec2 p = pp.xy;

    // Triangle resize
        p *= 0.5;

    // Triangle y offset
        p.y -= 0.58;

    // Triangle inner glow factor
        vec3 gcol = HSV2RGB(vec3(1.0, 0.8, 0.006*(1.0-(iAnimProgress_4.z))-((1.0-iAnimProgress_1.y)*0.004)));

    // Triangle displacement
        float dt = equilateralTriangle(p);

    // Triangle to scene visibility ratio
        col = dt < 0.0 ? fillColor : col;

    // Triangle edge glow modification
        col += (gcol / max(abs(dt), 0.001)) * smoothstep(0.5, 0.0, dt);
        return col;
    }
    vec3 anim_2(vec3 col, vec3 ro, vec3 rd) {
        vec2 fadein_fadeout = vec2(1.0-iAnimProgress_4.z, clamp(iAnimProgress_3.y * 2.0, 0.0, 1.0));

        // Triangle fill color
        vec3 fillColor = HSV2RGB(vec3(0.0, 0.3, 0.0));
        // Triangle glow color
        vec3 gcol;

        // Triangle calculations
        const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);
        float tpd = rayPlane(ro, rd, tpdim);
        vec3 pp = ro + rd * tpd;
        vec2 p = pp.xy;
        col = mix(col, HSV2RGB(vec3(0.0, 0.3, 1.0)), draw_text_pool(pp.xy, vec2(1.21, -1.6)) *0.5* (fadein_fadeout.x + iAnimProgress_1.y));
        col = mix(col, HSV2RGB(vec3(0.0, 0.0, 0.7)), draw_text_lock(pp.xy, vec2(0.87, -0.95)) * (iAnimProgress_2.z - fadein_fadeout.y));
        col = mix(col, HSV2RGB(vec3(0.0, 0.0, 0.7)), draw_text_execute(pp.xy, vec2(0.85, -1.25)) * (iAnimProgress_2.y ));

        vec2 p_tri_hedger = p;
        p_tri_hedger.x -= 0.0 + fadein_fadeout.x - iAnimProgress_2.x;
        vec2 p_hedger_text = p_tri_hedger;

        // Triangle glow color
        gcol = HSV2RGB(vec3(0.0, 0.9, 0.006*(fadein_fadeout.x-fadein_fadeout.y)-((1.0-iAnimProgress_1.z)*0.004)));
        // Triangle resize
        p_tri_hedger *= 1.0;
        // Triangle y offset
        p_tri_hedger.y -= 0.58;
        p_tri_hedger.x -= 1.0;
        // Triangle displacement
        float dt_hedger = equilateralTriangle(p_tri_hedger);
        // Triangle  visibility ratio
        if (dt_hedger < 0.0) {col = mix(fillColor, col, 0.0);}    // Triangle edge glow modification
        col += (gcol / max(abs(dt_hedger), 0.001)) * smoothstep(0.5, 0.0, dt_hedger);
        col = mix(col, HSV2RGB(vec3(0.0, 0.7, 1.0)), draw_text_hedger(p_hedger_text, vec2(0.0, -0.03)) *0.5* (fadein_fadeout.x + iAnimProgress_1.z)*(1.0-iAnimProgress_2.x));
        col = mix(col, HSV2RGB(vec3(0.0, 0.7 - (iAnimProgress_3.y), 1.0)), draw_text_party_b(p_hedger_text, vec2(0.1, -0.03)) * iAnimProgress_2.x);

        col = mix(col, HSV2RGB(vec3(0.0, 0.7, 1.0)), draw_text_intent_b(p_hedger_text, vec2(-0.03 + (sin(iAnimProgress_2.y * 3.142)) * 0.7, -0.25)) * ( iAnimProgress_2.x-iAnimProgress_2.y));
        col = mix(col, HSV2RGB(vec3(0.0, 0.7, 1.0)), draw_text_btc_short(p_hedger_text, vec2(+0.01 + (sin(iAnimProgress_2.y * 3.142)) * 0.7, -0.25)) * (iAnimProgress_2.y - fadein_fadeout.y));
        col = mix(col, HSV2RGB(vec3(0.0, 0.0, 0.7)), draw_text_plus_onethousand(p_hedger_text, vec2(-0.23, -0.55)) * (iAnimProgress_2.z - fadein_fadeout.y));

        vec2 p_tri_you = p;
        p_tri_you.x += 0.0 + fadein_fadeout.x - iAnimProgress_1.y;
        vec2 p_you_text = p_tri_you;

    // Triangle glow color
        gcol = HSV2RGB(vec3(0.0, 0.4, 0.006*(fadein_fadeout.x-fadein_fadeout.y)-((1.0-iAnimProgress_1.x)*0.003)));
    // Triangle resize
        p_tri_you *= 1.0;
    // Triangle y offset
        p_tri_you.y -= 0.58;
        p_tri_you.x += 1.0;
    // Triangle displacement
        float dt_you = equilateralTriangle(p_tri_you);
    // Triangle to scene visibility ratio
        if (dt_you < 0.0) {col = mix(fillColor, col, 0.0);}    // Triangle edge glow modification
    // Triangle edge glow modification
        col += (gcol / max(abs(dt_you), 0.001)) * smoothstep(0.5, 0.0, dt_you);

        col = mix(col, HSV2RGB(vec3(0.0, 0.0, 1.0)), draw_text_you(p_you_text, vec2(1.7, -0.03)) *0.5* (fadein_fadeout.x + iAnimProgress_1.x)*(1.0-iAnimProgress_1.y));
        col = mix(col, HSV2RGB(vec3(0.0, 0.0, 1.0)), draw_text_party_a(p_you_text, vec2(2.1, -0.03)) * iAnimProgress_1.y);
        col = mix(col, HSV2RGB(vec3(0.0, 0.0, 1.0)), draw_text_intent_a(p_you_text, vec2(1.97 - (sin(iAnimProgress_2.y * 3.142)) * 0.7, -0.25)) * (iAnimProgress_1.x - iAnimProgress_2.y));
        col = mix(col, HSV2RGB(vec3(0.0, 0.0, 1.0)), draw_text_btc_long(p_you_text, vec2(1.91 - (sin(iAnimProgress_2.y * 3.142)) * 0.7, -0.25)) * (iAnimProgress_2.y - fadein_fadeout.y));
        col = mix(col, HSV2RGB(vec3(0.0, 0.0, 0.7)), draw_text_plus_onethousand(p_you_text, vec2(1.78, -0.55)) * (iAnimProgress_2.z - fadein_fadeout.y));

        return col;
    }
    
    // Function for rendering the ground
    vec3 groundRender(vec3 col, vec3 ro, vec3 rd) {
        const vec3 gpn = normalize(vec3(0.0, 1.0, 0.0));
        const vec4 gpdim = vec4(gpn, 0.0);
        float gpd = rayPlane(ro, rd, gpdim);

        if(gpd < 0.0) {
            return col;

        }

    // Tiles reflection modifier
        vec3 gp = ro + rd * gpd;
        float gpfre = 1.15 + dot(rd, gpn);
        gpfre *= gpfre;
        gpfre *= gpfre;

        vec3 grr = reflect(rd, gpn);

        vec2 ggp = gp.xz;
        ggp.y += iTime;
        float dfy = dFdy(ggp.y);
        float gcf = sin(ggp.x) * sin(ggp.y);
        vec2 ggn;

    // Calculate the modulus
        vec2 c = floor(ggp);
        ggp = mod(ggp + vec2(0.5), vec2(1.0)) - vec2(0.5);
        ggn = c;

        float ggd = min(abs(ggp.x), abs(ggp.y));

    // Tiles lines color modifier
        vec3 gcol = HSV2RGB(vec3(0.01 * gcf, 0.7, 0.005 - (iAnimProgress_1.x * 0.002)));

        vec3 rcol = outerSkyRender(grr, grr);

        rcol = anim_1(rcol, gp, grr);
        rcol = anim_2(rcol, gp, grr);

        rcol *= 1.0 - (iAnimProgress_1.x * 0.7);
        // Tiles calculations
        col = gcol / max(ggd, 0.0 + 0.25 * dfy) * exp(-0.25 * gpd);

        // Ground horizon reflection color filter
        rcol += HSV2RGB(vec3(0.0, 0.0, 0.0));
        // Ground reflection factor
        col += rcol * gpfre / 2.0;

        return col;
    }

    void main() {

        const float fov = 2.0;

        vec3 ro;  // Camera location
        vec3 la;  // Camera look at
        if(iResolution.x > 1250.0 && iResolution.x>iResolution.y) {
            // Camera location right - left
            ro = vec3(0.0 ,
            //Camera location up - down
            0.5 ,
            //Camera location forth - back
            -5.0 );
            // Camrea look right - left
            la = vec3(-1.0-(iAnimProgress_4.z*2.0),
            // Camrea look up - down
            1.75,
            // Camrea look forth - back
            0.0 );
            // -------------------Small screen mode
        } else {
            // Camera location right - left
            ro = 1.0 * vec3(0.0,
            //Camera location up - down
            0.5+ ((iAnimProgress_4.z * 3.0)),
            //Camera location forth - back
            -12.0
            );
            // Camera look right - left
            la = vec3(0.0-(iAnimProgress_4.z*2.0) -iAnimProgress_1.y*1.0+iAnimProgress_1.z*1.0+iAnimProgress_2.x*1.0-iAnimProgress_2.y*1.0,
            // Camrea look up - down
            4.0-iAnimProgress_1.y*1.2 + iAnimProgress_3.y * 0.9- iAnimProgress_3.z * 1.0 - iAnimProgress_4.x * 2.0,
            // Camrea look forth - back
            0.0+ iAnimProgress_4.x * 20.3);
        };
        vec3 up = vec3(0.0, 1.0, 0.0);           // Up vector
            // Calculate camera coordinate system
        vec3 ww = normalize(la - ro);
        vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));
        vec3 vv = cross(uu, ww);
        vec2 q = (gl_FragCoord.xy / iResolution.xy - 0.5) * 2.0;
        vec2 p = q * vec2(iResolution.x / iResolution.y, 1.0);
            // Convert and adjust pixel coordinates

            // Calculate ray direction
        vec3 rd = normalize(-p.x * uu + p.y * vv + fov * ww);
            // Rendering process
        vec3 col = outerSkyRender(rd, rd);
        col = groundRender(col, ro, rd);

        col = anim_1(col, ro, rd);
        col = anim_2(col, ro, rd);


        gl_FragColor = vec4(col, 1.0);

    }

</script>
<script src="./script/howtotradeScript.js"></script>
</body>

</html>